# CodeLaunch SaaS Boilerplate - Cursor Rules

You are an expert full-stack developer working on CodeLaunch, a Next.js SaaS boilerplate with Stripe integration, NextAuth, MongoDB, and modern UI components.

## Project Overview
- **Tech Stack**: Next.js 15, React 19, NextAuth v5 (beta), MongoDB, Mongoose, Stripe, Tailwind CSS, DaisyUI, Resend
- **Architecture**: App Router, API Routes, Server Components, Client Components
- **Authentication**: NextAuth with Google OAuth and Email providers
- **Database**: MongoDB with Mongoose ODM
- **Payments**: Stripe Checkout and Customer Portal
- **Email**: Resend for transactional emails
- **UI**: Tailwind CSS with DaisyUI components

## Code Style & Conventions

### File Structure
- Use App Router structure (`app/` directory)
- API routes in `app/api/[endpoint]/route.js`
- Components in `components/` directory
- Utilities/libs in `libs/` directory
- Models in `models/` directory
- Configuration in `config.js`

### Naming Conventions
- **Components**: PascalCase (e.g., `ButtonCheckout.js`, `HeaderBlog.js`)
- **API Routes**: kebab-case directories with `route.js` files
- **Utilities**: camelCase (e.g., `connectMongo`, `createCheckout`)
- **Constants**: UPPER_SNAKE_CASE
- **Variables**: camelCase

### Component Patterns
- Use `"use client"` directive for client components
- Import config from `@/config` for app-wide settings
- Use absolute imports with `@/` prefix
- Export default for single-purpose components
- Include descriptive comments for complex components

### API Route Structure
```javascript
import { NextResponse } from "next/server";
import { auth } from "@/libs/auth";

export async function POST(req) {
  try {
    const session = await auth();
    const body = await req.json();
    
    // Validation
    if (!body.requiredField) {
      return NextResponse.json(
        { error: "Required field is missing" },
        { status: 400 }
      );
    }
    
    // Logic here
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Something went wrong" },
      { status: 500 }
    );
  }
}
```

### Database Patterns
- Use Mongoose for MongoDB operations
- Always call `connectMongo()` before database operations
- Use schema validation and plugins
- Include timestamps in schemas
- Use the `toJSON` plugin for clean API responses

### Authentication
- Use `auth()` from `@/libs/auth` to get session
- Check authentication in API routes when needed
- Use `session?.user?.id` to access user ID
- Redirect unauthenticated users to `config.auth.loginUrl`

### Stripe Integration
- Use `createCheckout()` from `@/libs/stripe` for payments
- Handle webhooks in `app/api/webhook/stripe/route.js`
- Store `customerId` and `priceId` in user model
- Use `hasAccess` field to control feature access

## Best Practices

### Error Handling
- Always wrap async operations in try-catch blocks
- Return appropriate HTTP status codes
- Log errors to console for debugging
- Provide user-friendly error messages

### Security
- Validate all inputs in API routes
- Use environment variables for sensitive data
- Implement proper CORS headers where needed
- Sanitize user inputs before database operations

### Performance
- Use Server Components by default
- Only use Client Components when necessary (interactivity, hooks)
- Implement proper loading states
- Use Next.js Image component for optimized images
- Leverage MongoDB indexes for queries

### UI/UX
- Use DaisyUI classes for consistent styling
- Implement loading states with DaisyUI spinners
- Use semantic HTML elements
- Ensure responsive design with Tailwind breakpoints
- Include proper accessibility attributes

## Environment Variables
Required environment variables:
- `NEXTAUTH_SECRET`
- `NEXTAUTH_URL`
- `MONGODB_URI`
- `STRIPE_PUBLIC_KEY`
- `STRIPE_SECRET_KEY`
- `STRIPE_WEBHOOK_SECRET`
- `GOOGLE_ID` (optional)
- `GOOGLE_SECRET` (optional)
- `RESEND_API_KEY`

## Common Patterns

### Client Component with API Call
```javascript
"use client";
import { useState } from "react";
import apiClient from "@/libs/api";

const ComponentName = () => {
  const [isLoading, setIsLoading] = useState(false);
  
  const handleAction = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.post("/endpoint", data);
      // Handle success
    } catch (error) {
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <button 
      className="btn btn-primary"
      onClick={handleAction}
      disabled={isLoading}
    >
      {isLoading ? (
        <span className="loading loading-spinner loading-xs"></span>
      ) : (
        "Action"
      )}
    </button>
  );
};
```

### Mongoose Model
```javascript
import mongoose from "mongoose";
import toJSON from "./plugins/toJSON";

const schema = mongoose.Schema(
  {
    field: {
      type: String,
      required: true,
      trim: true,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
  }
);

schema.plugin(toJSON);

export default mongoose.models.ModelName || mongoose.model("ModelName", schema);
```

## Configuration
- All app configuration is centralized in `config.js`
- Use `config.appName`, `config.domainName`, etc. throughout the app
- Stripe plans are defined in `config.stripe.plans`
- Email settings in `config.resend`
- Theme settings in `config.colors`

## Testing & Development
- Use `npm run dev` for development
- Use `npm run build` for production builds
- Follow conventional commit messages
- Test Stripe webhooks using Stripe CLI
- Use MongoDB Compass for database inspection

## Deployment Considerations
- Set all required environment variables
- Configure Stripe webhooks endpoint
- Set up MongoDB Atlas connection
- Configure domain for NextAuth
- Set up Resend domain for emails

Remember to always check the existing codebase patterns before implementing new features to maintain consistency. 